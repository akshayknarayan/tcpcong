// Tracepoint program for static kernel tracing
// Generated by KernelScript compiler with direct BTF parsing
include "tracepoint.kh"

enum IpAddressType {
    Ipv4,
    Ipv6,
}

struct IpAddress {
    type: IpAddressType,
    data: u8[16],
}

@helper
fn make_addr(family: u16, addr: u8[28]) -> IpAddress {
    if (family == AF_INET6) { // doesn't compile because we need bindings to AF_INET6
        var s : sockaddr_in6 = addr
        return IpAddress{ type: Ipv6, data: s->sin6_addr.in6_u.u6_addr8 }
    } else if (family == AF_INET) {
        var s : sockaddr_in = addr
        return IpAddress{ type: Ipv4, data: s->sin_addr.s_addr }
    }
}

struct Flow {
    addr_family: IpAddressType,
    src_ip: IpAddress,
    dst_ip: IpAddress,
    src_port: u16,
    dst_port: u16,
}

struct CongEvent {
    flow: Flow,
    snd_cwnd: u32,
    srtt: u32,
}

//var tcp_flows : hash<Flow, CongEvent>(32)

// Tracepoint event signature:
// Tracepoint event: tcp/tcp_probe -> fn(*trace_event_raw_tcp_probe) -> i32

// unknown btf_trace_tcp_probe (placeholder)

// tcp_probe format from /sys/kernel/debug/tracing/events/tcp/tcp_probe/format 
// format:
//     field:unsigned short  common_type;           offset:0;   size:2;  signed:0;
//     field:unsigned char   common_flags;          offset:2;   size:1;  signed:0;
//     field:unsigned char   common_preempt_count;  offset:3;   size:1;  signed:0;
//     field:int             common_pid;            offset:4;   size:4;  signed:1;
//                                                                                
//     field:__u8            saddr[28];             offset:8;   size:28; signed:0;
//     field:__u8            daddr[28];             offset:36;  size:28; signed:0;
//     field:__u16           sport;                 offset:64;  size:2;  signed:0;
//     field:__u16           dport;                 offset:66;  size:2;  signed:0;
//     field:__u16           family;                offset:68;  size:2;  signed:0;
//     field:__u32           mark;                  offset:72;  size:4;  signed:0;
//     field:__u16           data_len;              offset:76;  size:2;  signed:0;
//     field:__u32           snd_nxt;               offset:80;  size:4;  signed:0;
//     field:__u32           snd_una;               offset:84;  size:4;  signed:0;
//     field:__u32           snd_cwnd;              offset:88;  size:4;  signed:0;
//     field:__u32           ssthresh;              offset:92;  size:4;  signed:0;
//     field:__u32           snd_wnd;               offset:96;  size:4;  signed:0;
//     field:__u32           srtt;                  offset:100; size:4;  signed:0;
//     field:__u32           rcv_wnd;               offset:104; size:4;  signed:0;
//     field:__u64           sock_cookie;           offset:112; size:8;  signed:0;
//     field:const void*     skbaddr;               offset:120; size:8;  signed:0;
//     field:const void*     skaddr;                offset:128; size:8;  signed:0;
// 
// print fmt: "family=%s src=%pISpc dest=%pISpc mark=%#x data_len=%d snd_nxt=%#x snd_una=%#x snd_cwnd=%u ssthresh=%u snd_wnd=%u srtt=%u rcv_wnd=%u sock_cookie=%llx skbaddr=%p skaddr=%p", __print_symbolic(REC->family, { 2, "AF_INET" }, { 10, "AF_INET6" }), REC->saddr, REC->daddr, REC->mark, REC->data_len, REC->snd_nxt, REC->snd_una, REC->snd_cwnd, REC->ssthresh, REC->snd_wnd, REC->srtt, REC->rcv_wnd, REC->sock_cookie, REC->skbaddr, REC->skaddr
@tracepoint("tcp/tcp_probe")
fn tcp_tcp_probe_handler(ctx: *trace_event_raw_tcp_probe) -> i32 {
    return 0
}

fn main() -> i32 {
    var prog = load(tcp_tcp_probe_handler)
    
    // Attach tracepoint to target kernel event
    var result = attach(prog, "tcp/tcp_probe", 0)
    
    if (result == 0) {
        print("tracepoint program loaded successfully")
    } else {
        print("Failed to load tracepoint program")
        return 1
    }
    
    return 0
}
